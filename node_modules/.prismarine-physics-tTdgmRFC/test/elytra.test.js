/* eslint-env mocha */

const { Physics, PlayerState } = require('prismarine-physics')
const { Vec3 } = require('vec3')
const expect = require('expect')

const mcData = require('minecraft-data')('1.13.2')
const Block = require('prismarine-block')('1.13.2')

const fakeWorld = {
  getBlock: (pos) => {
    const type = (pos.y < 60) ? mcData.blocksByName.stone.id : mcData.blocksByName.air.id
    const b = new Block(type, 0, 0)
    b.position = pos
    return b
  }
}

const fakeWallWorld = {
  getBlock: (pos) => {
    const type = (pos.y < 60 || pos.x > 50) ? mcData.blocksByName.stone.id : mcData.blocksByName.air.id
    const b = new Block(type, 0, 0)
    b.position = pos
    return b
  }
}

const fakeWebWorld = {
  getBlock: (pos) => {
    const type = (pos.y < 60) ? mcData.blocksByName.stone.id : mcData.blocksByName.cobweb.id
    const b = new Block(type, 0, 0)
    b.position = pos
    return b
  }
}

const waterWorld = {
  getBlock: (pos) => {
    const type = (pos.y < 60) ? mcData.blocksByName.water.id : mcData.blocksByName.air.id
    const b = new Block(type, 0, 0)
    b.position = pos
    return b
  }
}

const lavaWorld = {
  getBlock: (pos) => {
    const type = (pos.y < 60) ? mcData.blocksByName.lava.id : mcData.blocksByName.air.id
    const b = new Block(type, 0, 0)
    b.position = pos
    return b
  }
}

function fakePlayer (pos) {
  return {
    entity: {
      position: pos,
      velocity: new Vec3(0, 0, 0),
      onGround: false,
      isInWater: false,
      isInLava: false,
      isInWeb: false,
      isCollidedHorizontally: false,
      isCollidedVertically: false,
      elytraFlying: false,
      yaw: Math.PI * 3 / 2, // east (+x)
      pitch: 20 * Math.PI / 180,
      effects: {}
    },
    jumpTicks: 0,
    jumpQueued: false,
    fireworkRocketDuration: 0,
    version: '1.13.2',
    inventory: {
      slots: []
    }
  }
}

function untilIdle (player, physics, world, controls) {
  const playerState = new PlayerState(player, controls)
  while (!playerState.onGround || playerState.vel.x !== 0 || playerState.vel.z !== 0) {
    physics.simulatePlayer(playerState, world)
  }
  playerState.apply(player)
}

function passTicks (ticks, player, physics, world, controls) {
  const playerState = new PlayerState(player, controls)
  for (let i = 0; i < ticks; ++i) {
    physics.simulatePlayer(playerState, world)
  }
  playerState.apply(player)
}

function mpsToTps (mps) {
  // 20 ticks per second
  return mps / 20
}

describe('Elytra tests', () => {
  it('flies east and then back', () => {
    const physics = Physics(mcData, fakeWorld)
    const controls = {
      forward: false,
      back: false,
      left: false,
      right: false,
      jump: false,
      sprint: false,
      sneak: false
    }
    const player = fakePlayer(new Vec3(0, 61, 0))
    player.inventory.slots[6] = { name: 'elytra' }

    // wait til on ground
    untilIdle(player, physics, fakeWorld, controls)

    expect(player.entity.position).toEqual(new Vec3(0, 60, 0))

    // jump
    player.jumpQueued = true
    passTicks(10, player, physics,